<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>è¸©åœ°é›· - ç´”é‚è¼¯é€²éšç‰ˆ</title>
<style>
  body, button, div, span, li, input, select {
    background-color: #FFFFFF;
    font-size: 18px;
    font-weight: bold;
    color: #333;
    font-family: sans-serif;
    font-style: normal;
  }
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-top: 10px;
    touch-action: manipulation;
    overflow-x: hidden;
  }
  #game-container {
    text-align: center;
    width: 100%;
    position: relative;
    z-index: 10;
    padding: 0 10px;
    box-sizing: border-box;
  }
  
  #playerName {
    width: 100%;
    max-width: 320px;
    box-sizing: border-box;
    padding: 8px;
    margin-bottom: 10px;
    border: 2px solid #333;
    text-align: center;
  }

  .setup-bar {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-bottom: 15px;
    gap: 10px;
  }

  .difficulty-selector {
    width: 100%;
    max-width: 320px;
    padding: 8px;
    border: 2px solid #333;
    text-align: center;
    cursor: pointer;
  }
  
  .custom-mines-container {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 10px;
  }
  
  #custom-mines {
    width: 80px;
    text-align: center;
    border: 2px solid #333;
    padding: 6px;
  }
  
  .status-bar {
    display: flex;
    justify-content: space-between;
    align-items: flex-end;
    width: 100%;
    max-width: 320px;
    margin: 0 auto 15px auto;
    padding: 0 5px;
    box-sizing: border-box;
  }

  .timer-section {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 8px;
  }

  /* ä¸Šæ–¹å°æŒ‰éˆ•å°ˆç”¨æ¨£å¼ */
  .top-toggle-btn {
    font-size: 14px;
    padding: 6px 10px;
    border: 2px solid #333;
    cursor: pointer;
  }
  .top-toggle-btn:active {
    color: #888;
    border-color: #888;
  }

  .board-wrapper {
    width: 100%;
    overflow-x: auto;
    text-align: center; 
    margin-bottom: 15px;
    padding-bottom: 10px; 
  }

  #minesweeper-board {
    display: inline-grid;
    gap: 2px;
    margin: 0 auto;
  }
  
  .cell {
    width: 32px;
    height: 32px;
    background-color: #E8E8E8; 
    border: 2px solid #333;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    user-select: none;
    box-sizing: border-box;
  }
  
  .cell:not(.revealed):hover {
    background-color: #D0D0D0; 
  }
  
  .cell.revealed {
    border: 1px solid #CCC;
    background-color: #FFFFFF; 
  }

  .brand-label {
    margin-top: 20px;
    margin-bottom: 10px;
  }

  .action-btn {
    margin-top: 10px;
    padding: 10px;
    border: 2px solid #333;
    cursor: pointer;
    width: 100%;
    max-width: 320px;
  }
  .action-btn:active {
    color: #888;
    border-color: #888;
  }

  #scoreboard {
    margin-top: 30px;
    border-top: 2px solid #333;
    padding-top: 15px;
    text-align: left;
    max-width: 320px;
    margin-left: auto;
    margin-right: auto;
  }
  .score-title {
    text-align: center;
    margin-bottom: 15px;
  }
  #score-list {
    list-style-type: none;
    padding: 0;
    margin: 0;
  }
  .score-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
    border-bottom: 1px dashed #CCC;
    padding-bottom: 4px;
    font-size: 16px;
  }
  
  .delete-btn {
    border: 1px solid #333;
    color: #333;
    background-color: #FFFFFF;
    cursor: pointer;
    font-size: 14px;
    margin-left: 10px;
    padding: 2px 6px;
  }
  .delete-btn:active {
    color: #888;
    border-color: #888;
  }

  .confetti {
    position: fixed;
    top: -10px;
    z-index: 9999;
    width: 12px;
    height: 12px;
    animation: fall linear forwards;
    opacity: 0.9;
  }
  @keyframes fall {
    to {
      transform: translateY(110vh) rotate(720deg);
    }
  }
</style>
</head>
<body>

<div id="game-container">
  <input type="text" id="playerName" placeholder="è«‹è¼¸å…¥ç©å®¶åç¨±" value="åŒ¿åç©å®¶">
  
  <div class="setup-bar">
    <select id="difficulty" class="difficulty-selector" onchange="changeDifficulty()">
      <option value="easy">åˆç´š (9x9 æ ¼)</option>
      <option value="hard">é€²éš (16x16 æ ¼)</option>
    </select>
    
    <div class="custom-mines-container">
      <label for="custom-mines">åœ°é›·æ•¸é‡ï¼š</label>
      <input type="number" id="custom-mines" value="10" min="1" onchange="initGame()">
    </div>
  </div>

  <div class="status-bar">
    <span style="margin-bottom: 2px;">ğŸ’£ å‰©é¤˜: <span id="mine-count">10</span></span>
    <div class="timer-section">
      <button id="mode-toggle-top" class="top-toggle-btn" onclick="toggleMode()">ç›®å‰æ¨¡å¼ï¼šâ›ï¸ æŒ–æ˜</button>
      <span>â±ï¸ æ™‚é–“: <span id="timer">0</span> ç§’</span>
    </div>
  </div>
  
  <div class="board-wrapper">
    <div id="minesweeper-board" oncontextmenu="event.preventDefault();"></div>
  </div>
  
  <button id="mode-toggle-bottom" class="action-btn" onclick="toggleMode()">ç›®å‰æ¨¡å¼ï¼šâ›ï¸ æŒ–æ˜</button>
  <button class="action-btn" onclick="initGame()">é‡æ–°é–‹å§‹</button>

  <div class="brand-label">designer: Chris</div>

  <div id="scoreboard">
    <div class="score-title" id="score-title-text">æ­·å²æœ€é€Ÿç´€éŒ„</div>
    <ul id="score-list">
    </ul>
  </div>
</div>

<script>
  let ROWS = 9;
  let COLS = 9;
  let TOTAL_MINES = 10;
  let currentDifficulty = 'easy';
  
  let board = [];
  let revealedCount = 0;
  let flagCount = 0;
  let isGameOver = false;
  let isFirstClick = true;
  
  let timerInterval;
  let seconds = 0;
  let isDigMode = true; 

  function changeDifficulty() {
    const diff = document.getElementById('difficulty').value;
    currentDifficulty = diff;
    if (diff === 'easy') {
      ROWS = 9; COLS = 9; 
      document.getElementById('custom-mines').value = 10;
    } else {
      ROWS = 16; COLS = 16; 
      document.getElementById('custom-mines').value = 40;
    }
    initGame();
  }

  function initGame() {
    clearInterval(timerInterval);
    seconds = 0;
    document.getElementById('timer').innerText = seconds;
    
    let desiredMines = parseInt(document.getElementById('custom-mines').value, 10);
    let maxMines = (ROWS * COLS) - 9; 
    
    if (isNaN(desiredMines) || desiredMines < 1) {
      desiredMines = 1;
      document.getElementById('custom-mines').value = 1;
    }
    if (desiredMines > maxMines) {
      desiredMines = maxMines;
      document.getElementById('custom-mines').value = maxMines;
      alert("åœ°é›·æ•¸éå¤šï¼ç‚ºç¢ºä¿éŠæˆ²èƒ½é †åˆ©å±•é–‹ï¼Œå·²è‡ªå‹•èª¿æ•´ç‚ºä¸Šé™ï¼š" + maxMines);
    }
    
    TOTAL_MINES = desiredMines;
    
    if (currentDifficulty === 'easy') {
      document.getElementById('score-title-text').innerText = `æ­·å²æœ€é€Ÿç´€éŒ„ (9x9, ${TOTAL_MINES}é›·)`;
    } else {
      document.getElementById('score-title-text').innerText = `æ­·å²æœ€é€Ÿç´€éŒ„ (16x16, ${TOTAL_MINES}é›·)`;
    }

    revealedCount = 0;
    flagCount = 0;
    isGameOver = false;
    isFirstClick = true;
    updateMineCountDisplay();
    
    board = [];
    for (let r = 0; r < ROWS; r++) {
      let row = [];
      for (let c = 0; c < COLS; c++) {
        row.push({
          r: r, c: c,
          isMine: false, revealed: false, flagged: false, neighborMines: 0
        });
      }
      board.push(row);
    }
    
    renderBoard();
    updateScoreBoard();
  }

  function getNeighbors(r, c) {
    let res = [];
    for (let dr = -1; dr <= 1; dr++) {
      for (let dc = -1; dc <= 1; dc++) {
        if (dr === 0 && dc === 0) continue;
        let nr = r + dr, nc = c + dc;
        if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) {
          res.push({r: nr, c: nc});
        }
      }
    }
    return res;
  }

  function calculateNeighbors() {
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        board[r][c].neighborMines = 0;
        if (board[r][c].isMine) continue;
        let count = 0;
        for (let n of getNeighbors(r, c)) {
          if (board[n.r][n.c].isMine) count++;
        }
        board[r][c].neighborMines = count;
      }
    }
  }

  function getSolveStats(startR, startC) {
    let safeSet = new Set();
    let mineSet = new Set();
    safeSet.add(`${startR},${startC}`);
    
    let toExpand = [{r: startR, c: startC}];
    while (toExpand.length > 0) {
      let curr = toExpand.pop();
      if (board[curr.r][curr.c].neighborMines === 0) {
        for (let n of getNeighbors(curr.r, curr.c)) {
          let key = `${n.r},${n.c}`;
          if (!safeSet.has(key)) {
            safeSet.add(key);
            toExpand.push(n);
          }
        }
      }
    }

    let changed = true;
    while (changed) {
      changed = false;
      let safeCells = Array.from(safeSet).map(s => {
        let parts = s.split(',');
        return {r: parseInt(parts[0]), c: parseInt(parts[1])};
      });

      for (let cell of safeCells) {
        let r = cell.r, c = cell.c;
        let mineCount = board[r][c].neighborMines;
        if (mineCount === 0) continue;

        let hiddenNeighbors = [];
        let flaggedCount = 0;

        for (let n of getNeighbors(r, c)) {
          let key = `${n.r},${n.c}`;
          if (mineSet.has(key)) {
            flaggedCount++;
          } else if (!safeSet.has(key)) {
            hiddenNeighbors.push(n);
          }
        }

        if (hiddenNeighbors.length === 0) continue;

        if (mineCount === flaggedCount + hiddenNeighbors.length) {
          for (let h of hiddenNeighbors) {
            mineSet.add(`${h.r},${h.c}`);
            changed = true;
          }
        }
        else if (mineCount === flaggedCount) {
          for (let h of hiddenNeighbors) {
            safeSet.add(`${h.r},${h.c}`);
            changed = true;
          }
        }
      }
    }

    return {
      isPerfect: safeSet.size === (ROWS * COLS - TOTAL_MINES),
      solvedCount: safeSet.size
    };
  }

  function placeMinesSolvable(firstR, firstC) {
    let attempts = 0;
    let maxSolved = -1;
    let bestBoardState = null;
    const MAX_ATTEMPTS = 500; 

    let validSpots = [];
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (Math.abs(r - firstR) > 1 || Math.abs(c - firstC) > 1) {
          validSpots.push({r, c});
        }
      }
    }

    while (attempts < MAX_ATTEMPTS) { 
      attempts++;
      
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          board[r][c].isMine = false;
        }
      }

      for (let i = validSpots.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [validSpots[i], validSpots[j]] = [validSpots[j], validSpots[i]];
      }

      for (let i = 0; i < TOTAL_MINES; i++) {
        board[validSpots[i].r][validSpots[i].c].isMine = true;
      }
      
      calculateNeighbors();

      let stats = getSolveStats(firstR, firstC);
      
      if (stats.isPerfect) {
        console.log(`ç”Ÿæˆ 100% é‚è¼¯åœ–ï¼å˜—è©¦æ¬¡æ•¸ï¼š${attempts}`);
        return; 
      }

      if (stats.solvedCount > maxSolved) {
        maxSolved = stats.solvedCount;
        bestBoardState = board.map(row => row.map(cell => ({...cell})));
      }
    }
    
    console.log(`è¼‰å…¥ç›²çŒœç‡æœ€ä½çš„æœ€ä½³åœ– (æœ€é«˜å¯è§£ ${maxSolved} æ ¼)`);
    board = bestBoardState.map(row => row.map(cell => ({...cell})));
  }

  function renderBoard() {
    const boardElement = document.getElementById('minesweeper-board');
    boardElement.innerHTML = '';
    
    boardElement.style.gridTemplateColumns = `repeat(${COLS}, 32px)`;
    boardElement.style.gridTemplateRows = `repeat(${ROWS}, 32px)`;
    
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.r = r;
        cell.dataset.c = c;
        
        cell.addEventListener('click', () => handleCellClick(r, c));
        cell.addEventListener('contextmenu', (e) => {
          e.preventDefault();
          if (!isGameOver) toggleFlag(r, c);
        });
        
        boardElement.appendChild(cell);
      }
    }
  }

  function updateCellUI(r, c) {
    const cellData = board[r][c];
    const index = r * COLS + c;
    const cellElement = document.getElementById('minesweeper-board').children[index];
    
    if (cellData.revealed) {
      cellElement.classList.add('revealed');
      if (cellData.isMine) {
        cellElement.innerText = 'ğŸ’£';
      } else if (cellData.neighborMines > 0) {
        cellElement.innerText = cellData.neighborMines;
        cellElement.style.color = getNumberColor(cellData.neighborMines);
      } else {
        cellElement.innerText = '';
      }
    } else {
      cellElement.classList.remove('revealed');
      cellElement.innerText = cellData.flagged ? 'ğŸš©' : '';
    }
  }

  function getNumberColor(num) {
    const colors = ['#333', '#333', '#333', '#333', '#333', '#333', '#333', '#333'];
    return colors[num - 1] || '#333';
  }

  function handleCellClick(r, c) {
    if (document.activeElement.id === 'playerName' || document.activeElement.id === 'custom-mines') {
      document.activeElement.blur();
    }
    if (isGameOver) return;
    if (!isDigMode) {
      toggleFlag(r, c);
      return;
    }
    revealCell(r, c);
  }

  function toggleFlag(r, c) {
    let cellData = board[r][c];
    if (cellData.revealed) return;
    
    if (!cellData.flagged) {
      if (flagCount >= TOTAL_MINES) return; 
      cellData.flagged = true;
      flagCount++;
    } else {
      cellData.flagged = false;
      flagCount--;
    }
    updateCellUI(r, c);
    updateMineCountDisplay();
  }

  function revealCell(r, c) {
    let cellData = board[r][c];
    if (cellData.revealed || cellData.flagged) return;
    
    if (isFirstClick) {
      isFirstClick = false;
      placeMinesSolvable(r, c); 
      
      timerInterval = setInterval(() => {
        seconds++;
        document.getElementById('timer').innerText = seconds;
      }, 1000);
    }
    
    cellData.revealed = true;
    revealedCount++;
    updateCellUI(r, c);
    
    if (cellData.isMine) {
      gameOver(false);
      return;
    }
    
    if (cellData.neighborMines === 0) {
      for (let n of getNeighbors(r, c)) {
        revealCell(n.r, n.c);
      }
    }
    
    checkWin();
  }

  // åŒæ­¥åˆ‡æ›ä¸Šä¸‹å…©å€‹æŒ‰éˆ•çš„é¡¯ç¤ºæ–‡å­—
  function toggleMode() {
    isDigMode = !isDigMode;
    const text = isDigMode ? "ç›®å‰æ¨¡å¼ï¼šâ›ï¸ æŒ–æ˜" : "ç›®å‰æ¨¡å¼ï¼šğŸš© æ’æ——";
    
    const topBtn = document.getElementById('mode-toggle-top');
    const bottomBtn = document.getElementById('mode-toggle-bottom');
    
    if(topBtn) topBtn.innerText = text;
    if(bottomBtn) bottomBtn.innerText = text;
  }

  function updateMineCountDisplay() {
    document.getElementById('mine-count').innerText = TOTAL_MINES - flagCount;
  }

  function checkWin() {
    if (!isGameOver && revealedCount === (ROWS * COLS) - TOTAL_MINES) {
      gameOver(true);
    }
  }

  function fireConfetti() {
    const colors = ['#FFB7B2', '#FFDAC1', '#E2F0CB', '#B5EAD7', '#C7CEEA', '#FF9AA2'];
    for (let i = 0; i < 80; i++) {
      let conf = document.createElement('div');
      conf.className = 'confetti';
      conf.style.left = Math.random() * 100 + 'vw';
      conf.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
      conf.style.animationDuration = (Math.random() * 2 + 2) + 's'; 
      conf.style.animationDelay = (Math.random() * 0.5) + 's';
      document.body.appendChild(conf);

      setTimeout(() => {
        if (conf.parentNode) conf.parentNode.removeChild(conf);
      }, 5000);
    }
  }

  function gameOver(isWin) {
    if (isGameOver) return; 
    
    isGameOver = true;
    clearInterval(timerInterval);
    
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (board[r][c].isMine) {
          board[r][c].revealed = true;
          updateCellUI(r, c);
        }
      }
    }
    
    setTimeout(() => {
      if (isWin) {
        fireConfetti(); 
        setTimeout(() => {
          alert("æ­å–œéé—œï¼æ‚¨çš„æ™‚é–“æ˜¯ï¼š" + seconds + " ç§’");
          saveRecord(seconds);
        }, 300); 
      } else {
        alert("è¸©åˆ°åœ°é›·äº†ï¼éŠæˆ²çµæŸã€‚");
      }
    }, 100);
  }

  function getStorageKey() {
    return currentDifficulty === 'hard' ? `minesweeperLogic_${TOTAL_MINES}M_16x16` : `minesweeperLogic_${TOTAL_MINES}M_9x9`;
  }

  function saveRecord(timeRecord) {
    const playerName = document.getElementById('playerName').value || 'åŒ¿åç©å®¶';
    const now = new Date();
    const dateStr = now.getFullYear() + '/' + 
                    String(now.getMonth() + 1).padStart(2, '0') + '/' + 
                    String(now.getDate()).padStart(2, '0') + ' ' + 
                    String(now.getHours()).padStart(2, '0') + ':' + 
                    String(now.getMinutes()).padStart(2, '0');
                    
    const newRecord = { name: playerName, time: timeRecord, date: dateStr };
    const key = getStorageKey();
    let records = JSON.parse(localStorage.getItem(key)) || [];
    
    records.push(newRecord);
    records.sort(function(a, b) { return a.time - b.time; });
    records = records.slice(0, 5); 
    
    localStorage.setItem(key, JSON.stringify(records));
    updateScoreBoard();
  }

  function updateScoreBoard() {
    const scoreList = document.getElementById('score-list');
    const key = getStorageKey();
    let records = JSON.parse(localStorage.getItem(key)) || [];
    scoreList.innerHTML = '';
    
    if (records.length === 0) {
      scoreList.innerHTML = '<li style="text-align:center; color:#888; border:none; padding-top:10px;">æš«ç„¡ç´€éŒ„</li>';
      return;
    }
    
    records.forEach(function(record, index) {
      const li = document.createElement('li');
      li.className = 'score-item';
      li.innerHTML = `
        <span>${index + 1}. ${record.name} (${record.time}ç§’)</span>
        <span>${record.date} <button class="delete-btn" onclick="deleteRecord(${index})">åˆªé™¤</button></span>
      `;
      scoreList.appendChild(li);
    });
  }

  function deleteRecord(index) {
    const key = getStorageKey();
    let records = JSON.parse(localStorage.getItem(key)) || [];
    records.splice(index, 1);
    localStorage.setItem(key, JSON.stringify(records));
    updateScoreBoard();
  }

  document.addEventListener('keydown', function(event) {
    if (event.keyCode === 13) {
      if (document.activeElement.id === 'playerName' || document.activeElement.id === 'custom-mines') {
        document.activeElement.blur();
        if (document.activeElement.id === 'custom-mines') {
          initGame();
        }
      }
    }
  });

  initGame();
</script>
</body>
</html>

